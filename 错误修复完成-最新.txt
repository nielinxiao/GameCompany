╔═══════════════════════════════════════════════════════════════╗
║         NullReference 和 FormatException 错误修复完成            ║
╚═══════════════════════════════════════════════════════════════╝

【修复的问题】
────────────────────────────────────────────────────────────────
1. IOCPSystem.Update() - 第53行
   错误: NullReferenceException
   原因: 回调函数可能为 null

2. MoneySinger.GetMoneyBack() - 第122行
   错误: FormatException: Input string was not in a correct format
   原因: 服务器返回的字符串无法转换为 double

3. AIDialog.GetEndChoise() - 第122行
   错误: NullReferenceException
   原因: choises 列表为 null

4. 服务器日志过于冗长
   问题: 控制台打印完整 JSON 内容，难以阅读

【修复详情】
────────────────────────────────────────────────────────────────

修复1: IOCPSystem.cs - 添加空检查和防御性编程
  位置: Assets\Scripts\SetUp\System\IOCPSystem.cs 第48-58行

  修改前:
    while(pkgs.TryDequeue(out Pkg pkg))
    {
        if (ServerCallBack.ContainsKey(pkg.Head.ServerCmd))
        {
            DebugUtils.Log($"Accept Message [{pkg.Head.ServerCmd}]");
            ServerCallBack[pkg.Head.ServerCmd].Invoke(pkg);
        }
        else
            DebugUtils.Log($"Accept Message without Lisenter[{pkg.Head.ServerCmd}]");
    }

  修改后:
    while(pkgs.TryDequeue(out Pkg pkg))
    {
        if (pkg?.Head != null && ServerCallBack.ContainsKey(pkg.Head.ServerCmd))
        {
            var callback = ServerCallBack[pkg.Head.ServerCmd];
            if (callback != null)
            {
                DebugUtils.Log($"Accept Message [{pkg.Head.ServerCmd}]");
                callback.Invoke(pkg);
            }
            else
            {
                DebugUtils.Log($"Accept Message with null callback [{pkg.Head.ServerCmd}]");
            }
        }
        else
            DebugUtils.Log($"Accept Message without Lisenter[{pkg?.Head?.ServerCmd}]");
    }

  改进:
    - 添加 pkg?.Head != null 空检查
    - 在调用前检查 callback 是否为 null
    - 使用空传播运算符 ?. 防止 null 引用
    - 增加了错误日志，便于调试

修复2: MoneySinger.cs - 添加异常处理和默认值
  位置: Assets\Scripts\Logic\Singer\MoneySinger.cs 第120-124行

  修改前:
    private void GetMoneyBack(Pkg pkg, Action<float> action)
    {
        float value=(float)Convert.ToDouble(pkg.Body.serverMessage.JsonValue);
        action?.Invoke(value);
    }

  修改后:
    private void GetMoneyBack(Pkg pkg, Action<float> action)
    {
        try
        {
            string jsonValue = pkg.Body.serverMessage.JsonValue;
            if (string.IsNullOrEmpty(jsonValue) || jsonValue == "null")
            {
                Debug.LogWarning("[MoneySinger] 服务器返回空利率，使用默认值 0.05");
                action?.Invoke(0.05f);
                return;
            }

            float value = (float)Convert.ToDouble(jsonValue);
            action?.Invoke(value);
        }
        catch (Exception ex)
        {
            Debug.LogError($"[MoneySinger] GetMoneyBack 解析失败: {ex.Message}, 使用默认利率 0.05");
            action?.Invoke(0.05f);
        }
    }

  改进:
    - 添加 try-catch 捕获转换异常
    - 检查 JsonValue 是否为空或 "null"
    - 使用默认利率 0.05 (5%) 作为后备值
    - 添加详细的错误日志

修复3: AIDialog.cs - 添加 null 检查
  位置: Assets\Scripts\Logic\Tool\AIDialog.cs 第120-127行

  修改前:
    public string GetEndChoise()
    {
        if(choises.Count!=0)
        {
            return choises[choises.Count-1].message.content;
        }
        return null;
    }

  修改后:
    public string GetEndChoise()
    {
        if(choises != null && choises.Count != 0)
        {
            return choises[choises.Count-1].message.content;
        }
        return null;
    }

  改进:
    - 在访问 Count 前检查 choises 是否为 null
    - 防止 JSON 反序列化失败时的空引用
    - 当 AI API 返回错误时安全返回 null

修复4: GameServer.cs - 减少日志冗长
  位置: C:\Users\Nie\Desktop\GameCompanyServer\World Server\Servc\GameServer.cs

  GetJson 处理器 (第289-303行):
    修改前:
      _log.LogGreen($"[GameServer] GetJson Hash - Key: {msg.JsonDicKey}, Field: {msg.JsonDoubleKey}, Value: {value ?? "null"}");
      _log.LogGreen($"[GameServer] GetJson String - Key: {msg.JsonKey}, Value: {value ?? "null"}");

    修改后:
      int valueLength = value?.Length ?? 0;
      _log.LogGreen($"[GameServer] GetJson Hash - Key: {msg.JsonDicKey}, Field: {msg.JsonDoubleKey}, Length: {valueLength}");
      _log.LogGreen($"[GameServer] GetJson String - Key: {msg.JsonKey}, Length: {valueLength}");

  SetJson 处理器 (第337-349行):
    修改前:
      _log.LogGreen($"[GameServer] SetJson Hash - Key: {msg.JsonDicKey}, Field: {msg.JsonDoubleKey}, Value: {msg.JsonValue}");
      _log.LogGreen($"[GameServer] SetJson String - Key: {msg.JsonKey}, Value: {msg.JsonValue}");

    修改后:
      int valueLength = msg.JsonValue?.Length ?? 0;
      _log.LogGreen($"[GameServer] SetJson Hash - Key: {msg.JsonDicKey}, Field: {msg.JsonDoubleKey}, Length: {valueLength}");
      _log.LogGreen($"[GameServer] SetJson String - Key: {msg.JsonKey}, Length: {valueLength}");

  改进:
    - 只打印 JSON 字符串的长度，不打印完整内容
    - 大幅减少控制台输出量
    - 保留关键信息用于调试（Key、Field、Length）

修复5: LocalDataStorage.cs - 初始化默认利率
  位置: C:\Users\Nie\Desktop\GameCompanyServer\World Server\Storage\LocalDataStorage.cs

  添加初始化方法:
    private void InitializeDefaultValues()
    {
        try
        {
            // 初始化利率（如果不存在）- 默认5%
            if (StringGet("money") == null)
            {
                StringSet("money", "0.05");
                LogInfo("[LocalStorage] 初始化默认利率: 0.05 (5%)");
            }

            // 可以在这里添加更多默认值初始化
            // 例如：股票列表、游戏配置等
        }
        catch (Exception ex)
        {
            LogError($"[LocalStorage] 初始化默认值失败: {ex.Message}");
        }
    }

  在构造函数中调用:
    public LocalDataStorage(string dataDirectory, int saveIntervalHours = 24)
    {
        // ... 现有代码 ...
        LoadFromDisk();

        // 初始化默认值（如果不存在）
        InitializeDefaultValues();
    }

  改进:
    - 服务器启动时自动创建 "money" 键，值为 0.05
    - 确保客户端首次查询利率时不会收到空值
    - 可扩展的初始化框架，便于添加其他默认值

═══════════════════════════════════════════════════════════════

【测试建议】
────────────────────────────────────────────────────────────────
1. 重新编译服务端
   - Visual Studio 重新生成解决方案
   - 确保没有编译错误

2. 重启服务端
   - 关闭旧的服务端进程
   - Visual Studio 按 F5 启动新服务端
   - 观察控制台：
     ✓ 日志只显示 Length，不显示完整 JSON
     ✓ 看到 "初始化默认利率: 0.05 (5%)"

3. 重启 Unity 客户端
   - 关闭 Unity 游戏
   - 重新运行游戏
   - 完成 TapTap 登录

4. 验证修复
   ✓ IOCPSystem 不再报 NullReferenceException
   ✓ MoneySinger 不再报 FormatException
   ✓ AIDialog 不再报 NullReferenceException
   ✓ 服务端日志清爽易读
   ✓ 游戏正常运行，不卡顿

═══════════════════════════════════════════════════════════════

【预期日志】
────────────────────────────────────────────────────────────────
服务端控制台:
  [LocalStorage] 加载String数据成功: X 条记录
  [LocalStorage] 初始化默认利率: 0.05 (5%)
  [GameServer] 服务器启动成功 - 端口: 45677
  [GameServer] 新客户端连接
  [GameServer] 收到命令: CheckPlayerCreatByFirst, 玩家: xxx
  [GameServer] GetJson Hash - Key: company, Field: xxx, Length: 234
  [GameServer] SetJson Hash - Key: company, Field: xxx, Length: 456
  [GameServer] GetJson String - Key: money, Length: 4

Unity 控制台:
  [MainGameMode] 开始进入主游戏模式
  [MoneySinger] 服务器返回空利率，使用默认值 0.05  (首次可能出现)
  Accept Message [ReturnJson]
  Accept Message [CheckPlayerCreatByFirst]

═══════════════════════════════════════════════════════════════

【修改的文件】
────────────────────────────────────────────────────────────────
客户端:
  ✓ Assets\Scripts\SetUp\System\IOCPSystem.cs
  ✓ Assets\Scripts\Logic\Singer\MoneySinger.cs
  ✓ Assets\Scripts\Logic\Tool\AIDialog.cs

服务端:
  ✓ C:\Users\Nie\Desktop\GameCompanyServer\World Server\Servc\GameServer.cs
  ✓ C:\Users\Nie\Desktop\GameCompanyServer\World Server\Storage\LocalDataStorage.cs

═══════════════════════════════════════════════════════════════

【关键改进】
────────────────────────────────────────────────────────────────
1. 防御性编程
   - 所有关键操作前检查 null
   - 使用空传播运算符 ?.
   - 增加 try-catch 异常处理

2. 后备值机制
   - 数据缺失时使用合理的默认值
   - MoneySinger 利率默认 5%
   - 避免因数据问题导致崩溃

3. 服务端初始化
   - 启动时自动创建必需的默认值
   - 确保客户端首次请求能获得有效数据

4. 日志优化
   - 减少冗长的 JSON 打印
   - 保留关键调试信息
   - 提高日志可读性

5. 错误提示
   - 添加详细的错误日志
   - 包含错误原因和使用的默认值
   - 便于问题定位和调试

═══════════════════════════════════════════════════════════════

【总结】

问题: 3个 NullReferenceException + 1个 FormatException + 日志冗长
原因: 缺少空检查 + 数据格式错误 + 缺少默认值 + 日志过于详细
修复: 添加空检查 + 异常处理 + 默认值初始化 + 日志优化
状态: ✅ 已全部修复

所有错误已修复，服务端日志已优化！✓
